<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Connection — Driver Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root {
      --accent:  #0066ff;
      --muted: #555; /* improved contrast */
      --success: #00b894;
      --whatsapp: #25D366;
      --error: #ff4757;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f4f6f9;
      -webkit-font-smoothing: antialiased;
      color: #222;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Navbar */
    .navbar {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      background: var(--accent);
      color: #fff;
      padding: 12px 18px;
      font-weight: 700;
      box-shadow: 0 4px 12px rgba(0, 102, 255, 0.15);
      flex-shrink: 0;
    }
    .navbar img { height: 34px; }
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-left: auto;
      margin-right: 8px;
      background: var(--error);
      transition: background 0.3s ease;
    }
    .status-indicator.connected {
      background: var(--success);
      animation: pulse 2s infinite;
    }
    @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:.7;} }

    /* Container */
    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Input card */
    .input-card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 12px 36px rgba(12, 36, 80, 0.06);
      padding: 32px;
      width: 100%;
      max-width: 420px;
      transition: all 0.45s ease;
    }
    .input-card.hidden {
      opacity: 0;
      transform: translateY(-20px);
      pointer-events: none;
    }

    /* Form elements */
    h3 { margin: 0 0 16px; font-size: 20px; font-weight: 700; }
    label { display:block; margin-bottom:6px; color:var(--muted); font-size:13px; font-weight:500; }
    input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e6e9ef;
      font-size: 15px;
      transition: all 0.2s ease;
    }
    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);
    }

    /* Buttons */
    .button {
      width: 100%;
      padding: 12px;
      border-radius: 10px;
      border: none;
      font-weight: 700;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      margin-top: 12px;
      font-size: 15px;
      transition: background 0.2s ease;
    }
    .button:hover:not(:disabled) { background: #0052cc; }
    .button:disabled { opacity: 0.6; cursor: not-allowed; }
    .button.whatsapp { background: var(--whatsapp); }
    .button.whatsapp:hover:not(:disabled) { background: #1da851; }
    .button.error { background: var(--error); }
    .button.error:hover:not(:disabled) { background: #ee5a6f; }

    /* Feedback boxes */
    .error-box, .success-box {
      padding: 10px 12px;
      border-radius: 8px;
      margin-top: 10px;
      display: none;
      font-size: 13px;
    }
    .error-box { background:#ffe5e5; border:1px solid var(--error); color:#c92a2a; }
    .success-box { background:#d4edda; border:1px solid var(--success); color:#155724; }

    #tracking_box { display:none; }

    /* Map section */
    .map-section {
      display: none;
      flex: 1;
      width: 100%;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 16px 40px rgba(12, 36, 80, 0.08);
      overflow: hidden;
      position: relative;
    }
    .map-section.show {
      display: flex;
      animation: fadeInUp 0.5s ease forwards;
    }
    @keyframes fadeInUp {
      from { opacity:0; transform:translateY(30px) scale(0.98); }
      to { opacity:1; transform:translateY(0) scale(1); }
    }
    #end_session {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: auto;
  padding: 10px 16px;
  font-size: 14px;
  z-index: 2100; /* above map controls */
}
    #map {
      width: 100%;
      height: 100%;
      min-height: 300px; /* ensures visible area after fade-in */
      flex: 1;
    }
    .bottom-stats {
      position: absolute;
      right: 20px;
      bottom: 20px;
      background: rgba(20,20,20,0.92);
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 600;
      display: none;
      z-index: 2000;
      color: #fff;
      font-size: 13px;
      backdrop-filter: blur(6px);
    }

    @media (max-width: 900px) {
      .input-card { max-width: 100%; }
      .container { padding: 14px 16px; }
      .bottom-stats { bottom: 14px; }
    }
    @media (max-width: 450px) {
      .input-card { padding: 22px; }
      .container { padding: 12px 10px; }
      .bottom-stats { bottom: 12px; padding: 8px 12px; font-size: 12px; }
    }
    @media (max-width: 350px) { .input-card { padding: 16px; } }
  </style>
</head>
<body>
  <!-- Navbar -->
  <div class="navbar" role="navigation">
    <img src="/static/logo.png" alt="logo" onerror="this.src='/static/placeholder.png'">
    <span>Connection — Driver</span>
    <div id="connection-status" class="status-indicator disconnected" title="Socket connection status"></div>
  </div>

  <!-- Main container -->
  <main class="container" role="main">
    <div class="input-card" id="input-card">
      <h3>Start a Delivery Session</h3>

      <label for="receiver_phone">Receiver Phone Number</label>
      <input id="receiver_phone" type="tel" placeholder="E.g. 0788 123 456" autocomplete="tel" aria-label="Receiver phone number" />

      <button class="button" id="create_btn">Create Session</button>

      <p class="notice">Please allow location access when your browser asks.</p>

      <div id="error-box" class="error-box"></div>
      <div id="success-box" class="success-box"></div>

      <div id="tracking_box">
        <a id="tracking_link" href="#" target="_blank" class="link-box"></a>
        <button class="button whatsapp" id="wa_send">Send via WhatsApp</button>
        <button class="button error" id="end_session">End Session</button>
      </div>
    </div>
  </main>

  <!-- Map section -->
  <div class="map-section" id="map-section">
    <div id="map"></div>
    <div id="stats" class="bottom-stats"></div>
  </div>
<script>
/* ===========================
   DRIVER DASHBOARD SCRIPT
   =========================== */

const BACKEND_URL = (() => {
  const host = window.location.hostname;
  if (host === "localhost" || host === "127.0.0.1") return "http://localhost:8000";
  return window.location.origin;
})();

const socket = io(BACKEND_URL, {
  transports: ["websocket", "polling"],
  reconnection: true,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  reconnectionAttempts: 5,
});

let map = null;
let driverMarker = null;
let receiverMarker = null;
let routePolyline = null;
let gpsStarted = false;
let gpsWatchId = null;

let delivery_id = null;
let hasShownMap = false;
let lastRouteCall = 0;
const ROUTE_THROTTLE_MS = 800;

/* ===========================
   UI helpers
   =========================== */

let errorHideTimer = null;
let successHideTimer = null;

function showError(message) {
  const errorBox = document.getElementById("error-box");
  if (!errorBox) return;
  errorBox.textContent = message;
  errorBox.style.display = "block";
  if (errorHideTimer) clearTimeout(errorHideTimer);
  errorHideTimer = setTimeout(() => {
    errorBox.style.display = "none";
    errorHideTimer = null;
  }, 5000);
}

function showSuccess(message) {
  const successBox = document.getElementById("success-box");
  if (!successBox) return;
  successBox.textContent = message;
  successBox.style.display = "block";
  if (successHideTimer) clearTimeout(successHideTimer);
  successHideTimer = setTimeout(() => {
    successBox.style.display = "none";
    successHideTimer = null;
  }, 5000);
}

function updateConnectionStatus(connected) {
  const indicator = document.getElementById("connection-status");
  if (!indicator) return;
  indicator.className = "status-indicator " + (connected ? "connected" : "disconnected");
}

/* ===========================
   Phone utilities (Rwanda)
   =========================== */

function normalizeRwandaNumber(raw) {
  if (!raw) return null;
  const digits = raw.replace(/\D/g, "");

  // Accepted forms:
  //  - 07XXXXXXXX (10 digits starting with 07) -> 2507XXXXXXXX
  //  - 7XXXXXXXX (9 digits starting with 7) -> 2507XXXXXXXX
  //  - 2507XXXXXXXX (12 digits) -> unchanged
  if (digits.startsWith("2507") && digits.length === 12) return digits;
  if (digits.startsWith("07") && digits.length === 10) return "250" + digits;
  if (digits.length === 9 && digits.startsWith("7")) return "250" + digits;
  return null; // invalid format
}

function formatKm(km) {
  return (km || 0).toFixed(2) + " km";
}

function formatMin(min) {
  return min == null ? "- min" : Math.round(min) + " min";
}

/* ===========================
   Map visibility + fix blank tiles
   =========================== */

function ensureMapVisible() {
  const section = document.getElementById("map-section");
  if (!section) return;
  if (!hasShownMap) {
    section.classList.add("show");
    hasShownMap = true;
  }
  // Leaflet requires invalidateSize after container becomes visible
  setTimeout(() => {
    if (map && typeof map.invalidateSize === "function") {
      map.invalidateSize();
    }
  }, 200);
}

/* ===========================
   Session management
   =========================== */

async function createSession() {
  const btn = document.getElementById("create_btn");
  const phoneInput = document.getElementById("receiver_phone");
  const trackingBox = document.getElementById("tracking_box");
  const linkElem = document.getElementById("tracking_link");

  if (!phoneInput) {
    showError("Phone input not found");
    return;
  }

  const normalized = normalizeRwandaNumber(phoneInput.value.trim());
  if (!normalized) {
    showError("Enter a valid Rwanda number (e.g., 0788 123 456)");
    return;
  }

  if (btn) btn.disabled = true;

  let data;
  try {
    const res = await fetch(BACKEND_URL + "/driver/create-session", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ receiver_phone: normalized }),
      credentials: "include",
    });

    // Parse JSON safely
    try {
      data = await res.json();
    } catch (e) {
      showError("Invalid server response");
      if (btn) btn.disabled = false;
      return;
    }

    if (!res.ok) {
      showError(data?.error || "Failed to create session");
      if (btn) btn.disabled = false;
      return;
    }
  } catch (err) {
    console.error(err);
    showError("Network error: " + (err?.message || "Unknown"));
    if (btn) btn.disabled = false;
    return;
  }

  // Success flow
  delivery_id = data.delivery_id;

  if (data.tracking_link && linkElem && trackingBox) {
    linkElem.href = data.tracking_link;
    linkElem.textContent = data.tracking_link;
    trackingBox.style.display = "block";
    showSuccess("Session created! Share the tracking link.");
  } else {
    showError("Tracking link not generated");
    if (btn) btn.disabled = false;
    return;
  }

  // Join socket room reliably
  const joinPayload = { delivery_id, role: "driver" };
  if (socket && socket.connected) {
    socket.emit("join_delivery", joinPayload);
  } else if (socket) {
    const onceConnect = () => {
      socket.emit("join_delivery", joinPayload);
      socket.off("connect", onceConnect);
    };
    socket.on("connect", onceConnect);
  }

  // Reveal the map and fix blank tiles after fade-in
  ensureMapVisible();

  // Re-enable the button to allow another session if needed
  if (btn) btn.disabled = false;
}

/* ===========================
   Socket connection indicators
   =========================== */

socket.on("connect", () => updateConnectionStatus(true));
socket.on("disconnect", () => updateConnectionStatus(false));
socket.on("connect_error", () => updateConnectionStatus(false));

/* ===========================
   DRIVER DASHBOARD SCRIPT — Part 2
   =========================== */

function showMapSection() {
  if (hasShownMap) return;
  hasShownMap = true;

  const inputCard = document.getElementById('input-card');
  const mapSection = document.getElementById('map-section');

  inputCard.classList.add('hidden');
  mapSection.classList.add('show'); // make visible immediately

  // Delay map init until after fade-in
  setTimeout(() => {
    initMap();

    if (map) {
      map.invalidateSize();
      if (driverMarker) {
        map.setView(driverMarker.getLatLng(), 16);
      }
    }

    // GPS setup
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => {
          const lat = pos.coords.latitude;
          const lng = pos.coords.longitude;

          if (!driverMarker && map) {
            driverMarker = createMarker(lat, lng, "driver", "Driver");
            driverMarker.addTo(map);
          }

          if (delivery_id) {
            socket.emit("driver_update", { delivery_id, lat, lng, speed: 0 });
          }
        },
        err => {
          console.warn("GPS failed:", err);
          showError("Please enable GPS to track delivery");
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    if (!gpsStarted) {
      startGPS();
      gpsStarted = true;
    }
  }, 700); // match CSS animation
}

// Handle resize/orientation changes
function refreshMapView() {
  if (map) {
    map.invalidateSize();
    if (driverMarker) {
      map.setView(driverMarker.getLatLng(), 16);
    }
  }
}
window.addEventListener("resize", refreshMapView);
window.addEventListener("orientationchange", refreshMapView);

function resetUI() {
  delivery_id = null;
  hasShownMap = false;
  document.getElementById("receiver_phone").value = "";

  if (gpsWatchId) {
    navigator.geolocation.clearWatch(gpsWatchId);
    gpsWatchId = null;
  }
  gpsStarted = false;

  if (map) {
    map.off();
    map.remove();
    map = null;
  }
  driverMarker = null;
  receiverMarker = null;
  routePolyline = null;

  const inputCard = document.getElementById('input-card');
  const mapSection = document.getElementById('map-section');

  mapSection.classList.remove('show');
  inputCard.classList.remove('hidden');
  document.getElementById("create_btn").disabled = false;
}

let whatsappOpened = false;
let waitingForReturn = false;

function sendWhatsApp() {
  const raw = document.getElementById("receiver_phone").value;
  const phone = cleanPhone(raw);
  const link = document.getElementById("tracking_link").href;

  if (!link) {
    showError("Tracking link not available");
    return;
  }
  if (!phone) {
    showError("Invalid phone number for WhatsApp");
    return;
  }

  const message = "Track me live:\n" + link;
  window.open("https://wa.me/" + phone + "?text=" + encodeURIComponent(message), "_blank");

  whatsappOpened = true;
  waitingForReturn = true;
}

// Unified handleReturn
async function handleReturn() {
  try {
    await new Promise(resolve => setTimeout(resolve, 700)); // delay for 700ms
    showMapSection();
  } catch (error) {
    console.error("Error showing map section:", error);
    // Handle the error appropriately
  }
}
window.addEventListener("focus", handleReturn);
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible") {
    handleReturn();
  }
});

/* ===========================
   End Session
   =========================== */
async function endSession() {
  if (!delivery_id) {
    showError("No active session to end");
    return;
  }

  try {
    const res = await fetch(BACKEND_URL + "/driver/end-session", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delivery_id }),
      credentials: "include",
    });

    const data = await res.json();
    if (!res.ok) {
      showError(data.error || "Failed to end session");
      return;
    }

    showSuccess("Session ended successfully");
  } catch (err) {
    console.error(err);
    showError("Network error: " + err.message);
  }

  resetUI();
}

/* Map & Markers */
function createMarker(lat, lng, type, title) {
  const icons = {
    driver: '/static/driver.png',
    receiver: '/static/receiver.png'
  };

  const icon = L.icon({
    iconUrl: icons[type] || '/static/placeholder.png',
    iconSize: [32, 32],
    iconAnchor: [16, 32],
    popupAnchor: [0, -32],
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
    shadowSize: [41, 41],
    shadowAnchor: [12, 41]
  });

  return L.marker([lat, lng], { icon, title });
}

function initMap() {
  if (map) return;

  try {
    const mapDiv = document.getElementById('map');
    map = L.map(mapDiv, {
      zoomControl: false,
      attributionControl: true
    }).setView([-1.94995, 30.0588], 14);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    if (window.innerWidth > 700) {
      L.control.zoom({ position: 'topright' }).addTo(map);
    }
    map.attributionControl.setPosition('bottomright');
  } catch (err) {
    console.error("Map init error:", err);
    showError("Failed to initialize map");
  }
}

/* ===========================
   DRIVER DASHBOARD SCRIPT — Part 3
   =========================== */

function smoothMoveMarker(marker, newLat, newLng, duration = 800) {
  if (!marker) return;
  const startPos = marker.getLatLng();
  const endPos = L.latLng(newLat, newLng);
  const startTime = performance.now();

  function animate(t) {
    const progress = Math.min((t - startTime) / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    const currentLat = startPos.lat + (endPos.lat - startPos.lat) * eased;
    const currentLng = startPos.lng + (endPos.lng - startPos.lng) * eased;
    marker.setLatLng([currentLat, currentLng]);
    if (progress < 1) requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}

function drawPolyline(poly) {
  if (!map) return;
  if (routePolyline) {
    map.removeLayer(routePolyline);
    routePolyline = null;
  }
  if (!poly || poly.length === 0) return;

  routePolyline = L.polyline(poly, {
    color: "#0077ff",
    weight: 5,
    opacity: 0.95
  }).addTo(map);

  fitMapToActors();
}

function fitMapToActors() {
  if (!map) return;
  let bounds = L.latLngBounds([]);
  if (driverMarker) bounds.extend(driverMarker.getLatLng());
  if (receiverMarker) bounds.extend(receiverMarker.getLatLng());
  if (routePolyline) bounds.extend(routePolyline.getBounds());
  if (bounds.isValid()) {
    map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17, animate: true });
  }
}

/* Routes & GPS */
async function requestRoute(start, end) {
  if (!start || !end) return;
  const now = Date.now();
  if (now - lastRouteCall < ROUTE_THROTTLE_MS) return;
  lastRouteCall = now;

  try {
    const res = await fetch(BACKEND_URL + "/api/route", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ start, end })
    });

    let j;
    try {
      j = await res.json();
    } catch {
      console.error("Invalid route response");
      return;
    }

    if (!res.ok || !j) return;

    let poly = (j.polyline && Array.isArray(j.polyline) && j.polyline.length > 1)
      ? j.polyline
      : [[start.lat, start.lng], [end.lat, end.lng]];

    drawPolyline(poly);

    const stats = document.getElementById("stats");
    if (stats) {
      const distanceKm = j.distance_km;
      const etaMin = j.eta_min;
      stats.style.display = "block";
      stats.innerText =
        (distanceKm ? formatKm(distanceKm) : "- km") + " · " +
        (etaMin ? formatMin(etaMin) : "- min");
    }
  } catch (err) {
    console.error("Route error:", err);
  }
}

function startGPS() {
  if (!navigator.geolocation) {
    showError("GPS not supported on this device");
    return;
  }

  gpsWatchId = navigator.geolocation.watchPosition(
    pos => {
      const lat = pos.coords.latitude;
      const lng = pos.coords.longitude;
      const speed = pos.coords.speed || 0;

      if (!map) initMap();

      if (!driverMarker && map) {
        driverMarker = createMarker(lat, lng, "driver", "Driver");
        driverMarker.addTo(map);
        map.setView([lat, lng], 16);
      } else if (driverMarker) {
        smoothMoveMarker(driverMarker, lat, lng);
      }

      if (delivery_id) {
        socket.emit("driver_update", { delivery_id, lat, lng, speed });
      }

      if (receiverMarker) {
        const rpos = receiverMarker.getLatLng();
        requestRoute({ lat, lng }, { lat: rpos.lat, lng: rpos.lng });
      }

      fitMapToActors();
    },
    err => {
      console.warn("GPS error:", err);
      if (err.code === 1) {
        showError("GPS permission denied");
      }
    },
    { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
  );
}

/* Socket Events */
socket.on("connect", () => {
  console.log("Connected");
  updateConnectionStatus(true);
  if (delivery_id) socket.emit("join_delivery", { delivery_id, role: "driver" });
  if (hasShownMap && !gpsStarted) {
    startGPS();
    gpsStarted = true;
  }
});

socket.on("disconnect", () => {
  console.log("Disconnected");
  updateConnectionStatus(false);
});

socket.on("error", (error) => {
  console.error("Socket error:", error);
  showError("Connection error: " + (error.message || "Unknown"));
});

socket.on("driver_update", (data) => {
  if (!data || data.lat === undefined) return;
  const lat = parseFloat(data.lat);
  const lng = parseFloat(data.lng);

  if (!map) initMap();

  if (!driverMarker && map) {
    driverMarker = createMarker(lat, lng, "driver", "Driver");
    driverMarker.addTo(map);
  } else if (driverMarker) {
    smoothMoveMarker(driverMarker, lat, lng);
  }

  if (receiverMarker) {
    const rpos = receiverMarker.getLatLng();
    requestRoute({ lat, lng }, { lat: rpos.lat, lng: rpos.lng });
  }

  fitMapToActors();
});

socket.on("receiver_update", (data) => {
  if (!data || data.lat === undefined) return;
  const lat = parseFloat(data.lat);
  const lng = parseFloat(data.lng);

  if (!map) initMap();

  if (!receiverMarker && map) {
    receiverMarker = createMarker(lat, lng, "receiver", "Receiver");
    receiverMarker.addTo(map);
  } else if (receiverMarker) {
    smoothMoveMarker(receiverMarker, lat, lng);
  }

  if (driverMarker) {
    const dpos = driverMarker.getLatLng();
    requestRoute({ lat: dpos.lat, lng: dpos.lng }, { lat, lng });
  } else if (map) {
    map.setView([lat, lng], 14);
  }

  fitMapToActors();
});

socket.on("join_delivery", (data) => {
  console.log("Joined delivery:", data);
});

socket.on("error_event", (error) => {
  console.error("Server error:", error);
  showError("Server error: " + (error.error || "Unknown"));
});

/* Receiver simulation */
function simulateReceiver(lat, lng) {
  if (!delivery_id) {
    showError("No active delivery");
    return;
  }
  // Update local marker immediately for feedback
  if (!receiverMarker && map) {
    receiverMarker = createMarker(lat, lng, "receiver", "Receiver").addTo(map);
  } else if (receiverMarker) {
    smoothMoveMarker(receiverMarker, lat, lng);
  }
  socket.emit("receiver_update", { delivery_id, lat, lng });
}

window.addEventListener("resize", () => {
  if (map) map.invalidateSize();
});

window.addEventListener("beforeunload", () => {
  if (gpsWatchId) {
    navigator.geolocation.clearWatch(gpsWatchId);
  }
  if (socket) socket.disconnect();
});
</script>
</body>
</html>